#!/usr/bin/env ruby
# frozen_string_literal: true

require "thor"
require "yaml"
require "fileutils"
require "ruby_llm"
require "net/http"

class GitCommitCLI < Thor
  CONFIG_DIR = File.join(Dir.home, ".git_commit_cli")
  CONFIG_FILE = File.join(CONFIG_DIR, "config.yml")
  DEFAULT_SYSTEM_PROMPT = <<~PROMPT.freeze
    # Generate Commit Message

    Generate a clear, concise commit message for my uncommitted changes.

    ## Context

    I need a commit message that follows conventional commit format without emojis, written in a natural, human tone. The message should be informative yet brief, capturing what was done and why when relevant.

    ## Format Requirements

    Use this structure:
    ```
    type(scope): #issue_number short descriptive title

    - Brief description of what changed
    - Why it was changed (if not obvious)
    - Any side effects or important notes

    Closes #issue_number
    ```

    ### Commit Types
    - `feat`: New feature or functionality
    - `fix`: Bug fix or error correction  
    - `perf`: Performance improvements
    - `refactor`: Code restructuring without changing functionality
    - `style`: Formatting, spacing, semicolons (no code change)
    - `docs`: Documentation updates
    - `test`: Adding or updating tests
    - `chore`: Maintenance tasks, dependency updates
    - `build`: Build system or external dependency changes
    - `ci`: CI/CD configuration changes
    - `revert`: Reverting a previous commit

    ### Scope Examples
    - Component name: `feat(UserProfile):`
    - Module name: `fix(auth):`
    - Feature area: `perf(search):`
    - File type: `docs(README):`

    ## Guidelines

    1. **Title line**: Maximum 50 characters, imperative mood ("add" not "added")
    2. **Description**: 
       - Use bullet points for multiple changes
       - Focus on what and why, not how
       - Keep each line under 72 characters
    3. **Natural tone**: Write like explaining to a colleague
    4. **Be specific**: "Fix null check in payment processing" not "Fix bug"
    5. **No fluff**: Skip obvious things like "Update code" or "Make changes"
    6. **No AI generated info**: Please don't add messages like Generated by AI, and don't add Co-Authored by section. Keep the message clean and follow the guideline given here.

    ## Examples

    ### Feature Addition
    ```
    feat(checkout): #234 add guest checkout option

    - Allow users to complete purchase without account
    - Store guest orders with email reference
    - Add order lookup by email and order ID

    Closes #234
    ```

    ### Bug Fix
    ```
    fix(api): #456 handle timeout errors in payment gateway

    - Catch and retry failed payments up to 3 times
    - Show user-friendly error after final attempt
    - Log detailed errors for debugging

    Closes #456
    ```

    Based on the git diff provided, generate a commit message following these guidelines. If no issue number is provided, omit it from the message.
  PROMPT

  desc "setup", "Configure custom system prompt for commit messages"
  option :system_prompt, type: :string, desc: "Custom system prompt for commit messages"
  option :reset, type: :boolean, desc: "Reset to default system prompt"
  def setup
    ensure_config_dir
    config = load_config

    if options[:reset]
      config[:system_prompt] = DEFAULT_SYSTEM_PROMPT
      save_config(config)
      puts "Reset to default system prompt."
      return
    end

    if options[:system_prompt]
      config[:system_prompt] = options[:system_prompt]
    else
      puts "Current system prompt: #{config[:system_prompt] ? "Custom" : "Default"}"
      
      if yes?("\nWould you like to customize the system prompt? (y/n)")
        puts "\nEnter your custom system prompt (press Ctrl+D when done):"
        custom_prompt = $stdin.read
        config[:system_prompt] = custom_prompt
      else
        config[:system_prompt] = DEFAULT_SYSTEM_PROMPT
        puts "Using default system prompt."
      end
    end

    save_config(config)
    puts "\nConfiguration saved to #{CONFIG_FILE}"
  end

  def initialize_chat(provider = nil, model = nil)
    if ENV.fetch('OLLAMA_API_BASE', nil).nil?
      RubyLLM.chat(model: model)
    else
      RubyLLM.configure do |config|
        config.ollama_api_base = "http://localhost:11434/v1"
      end
      
      RubyLLM.chat(model: model || "gemma3:12b", provider: :ollama)
    end
  end

  desc "commit", "Generate and commit with an AI-generated commit message"
  option :prompt, type: :string, desc: "Additional instructions for the LLM"
  option :stage_all, type: :boolean, aliases: "-a", desc: "Stage all unstaged changes before committing"
  option :issue, type: :string, aliases: "-i", desc: "Issue/ticket number to include in the commit message"
  option :model, type: :string, aliases: "-m", desc: "Specific model to use (e.g., gpt-4, claude-3-opus)"
  def commit
    check_git_installed
    
    # Load configuration for system prompt
    config = load_config
    system_prompt = config[:system_prompt] || DEFAULT_SYSTEM_PROMPT

    # Configure RubyLLM (it will auto-detect provider from env vars)
    configure_llm

    # Stage all changes if requested
    if options[:stage_all]
      system("git add .")
      puts "Staged all changes."
    end

    # Check if there are staged changes
    staged_changes = `git diff --staged`
    if staged_changes.empty?
      unstaged_changes = `git diff`
      if unstaged_changes.empty?
        puts "No changes to commit."
        return
      else
        puts "No staged changes found, but there are unstaged changes."
        if yes?("Would you like to stage all changes? (y/n)")
          system("git add .")
          puts "Staged all changes."
          staged_changes = `git diff --staged`
        else
          puts "No changes were staged. Exiting."
          return
        end
      end
    end

    # Get staged and unstaged changes info
    staged_files = `git diff --staged --name-only`.split("\n")
    unstaged_files = `git diff --name-only`.split("\n")
    
    puts "\nAnalyzing changes..."
    puts "Staged files: #{staged_files.join(", ")}" unless staged_files.empty?
    puts "Unstaged files: #{unstaged_files.join(", ")}" unless unstaged_files.empty?
    puts ""

    # Prepare prompt with additional user instructions if provided
    user_prompt = "Here are the git changes to summarize in a commit message:\n\n#{staged_changes}\n\n"
    
    # Add issue number if provided
    user_prompt += "Issue/ticket number: ##{options[:issue]}\n\n" if options[:issue]
    
    # Add additional instructions if provided
    user_prompt += "Additional instructions: #{options[:prompt]}" if options[:prompt]

    # Generate commit message
    puts "Generating commit message..."
    begin
      # Add model if specified
      # TODO: better way to choose model and provider
      # chat_options[:model] = options[:model] if options[:model]
      
      chat = initialize_chat(nil, options[:model])
      response = chat.ask user_prompt
      commit_message = response.content

      puts "Model Used: #{response.model_id}"
      puts "Tokens Used: #{response.input_tokens} input, #{response.output_tokens} output"
      puts "PROMPT used: #{user_prompt}"
      puts
      puts "\nGenerated commit message:"
      puts "------------------------"
      puts commit_message
      puts "------------------------"
      puts 
      
      # Confirm with user
      if yes?("\nUse this commit message? (y/n)")
        system("git", "commit", "-m", commit_message)
        puts "Changes committed successfully!"
      else
        if yes?("Would you like to regenerate the message? (y/n)")
          # Recursively call commit to regenerate
          commit
        else
          puts "Commit canceled."
        end
      end
    rescue => e
      puts "Error generating commit message: #{e.message}"
      
      if e.message.include?("API key") || e.message.include?("authenticate") || e.message.include?("configuration")
        puts "\nNo LLM provider configured. Please set one of the following:"
        puts "  export OPENAI_API_KEY='your-key-here'"
        puts "  export ANTHROPIC_API_KEY='your-key-here'"
        puts "  export GEMINI_API_KEY='your-key-here'"
        puts "  export DEEPSEEK_API_KEY='your-key-here'"
        puts "  export MISTRAL_API_KEY='your-key-here'"
        puts "  export PERPLEXITY_API_KEY='your-key-here'"
        puts "\nOr install Ollama for local models: https://ollama.ai"
        puts "\nExample usage:"
        puts "  OPENAI_API_KEY='sk-...' git-commit commit"
        puts "  ANTHROPIC_API_KEY='sk-ant-...' git-commit commit --model claude-3-opus"
      end
      
      if yes?("\nWould you like to enter a commit message manually? (y/n)")
        manual_message = ask("Enter your commit message:")
        system("git", "commit", "-m", manual_message)
        puts "Changes committed successfully!"
      else
        puts "Commit canceled."
      end
    end
  end

  desc "info", "Show information about the current configuration and available models"
  def info
    config = load_config
    configure_llm
    
    puts "Git Commit CLI Information"
    puts "=========================="
    
    # Display available models using RubyLLM's models API
    puts "\nAvailable Models:"
    puts "-----------------"
    
    begin
      # Group models by provider
      models_by_provider = {}
      
      RubyLLM.models.chat_models.each do |model|
        provider = model.provider.to_s
        models_by_provider[provider] ||= []
        models_by_provider[provider] << model.id
      end
      
      if models_by_provider.empty?
        puts "No models available. Please configure at least one provider."
      else
        models_by_provider.each do |provider, models|
          puts "\n#{provider.capitalize}:"
          models.each do |model_id|
            puts "  - #{model_id}"
          end
        end
      end
    rescue => e
      # If RubyLLM.models doesn't work, check for environment variables
      providers = []
      providers << "OpenAI" if ENV['OPENAI_API_KEY']
      providers << "Anthropic" if ENV['ANTHROPIC_API_KEY']
      providers << "Gemini" if ENV['GEMINI_API_KEY']
      providers << "DeepSeek" if ENV['DEEPSEEK_API_KEY']
      providers << "Mistral" if ENV['MISTRAL_API_KEY']
      providers << "Perplexity" if ENV['PERPLEXITY_API_KEY']
      
      # Check for Ollama
      ollama_base = ENV.fetch('OLLAMA_API_BASE', 'http://localhost:11434/v1')
      if check_ollama_connectivity(ollama_base)
        providers << "Ollama (local)"
      end
      
      if providers.empty?
        puts "No LLM providers configured!"
        puts "\nTo use this tool, set one of the following environment variables:"
        puts "  - OPENAI_API_KEY for OpenAI models"
        puts "  - ANTHROPIC_API_KEY for Claude models"
        puts "  - GEMINI_API_KEY for Google Gemini"
        puts "  - Or install Ollama for local models"
      else
        puts "Available providers (detected from environment): #{providers.join(", ")}"
        puts "\nNote: Unable to list specific models. Run a test commit to verify configuration."
      end
    end
    
    puts "\nSystem Prompt: #{config[:system_prompt] ? "Custom" : "Default"}"
    puts "\nUsage Examples:"
    puts "  git-commit commit                    # Generate commit with default model"
    puts "  git-commit commit -a                 # Stage all changes and commit"
    puts "  git-commit commit --model gpt-4      # Use specific model"
    puts "  git-commit commit --issue 123        # Include issue number"
    puts "  git-commit setup                     # Customize system prompt"
  end

  desc "install", "Install the git-commit command globally"
  def install
    script_path = File.expand_path(__FILE__)
    bin_dir = "/usr/local/bin"
    
    if File.exist?(bin_dir) && File.writable?(bin_dir)
      FileUtils.ln_sf(script_path, "#{bin_dir}/git-commit")
      puts "Installed git-commit to #{bin_dir}/git-commit"
      puts "You can now use 'git-commit' command from anywhere."
    else
      puts "Cannot install to #{bin_dir} (permission denied)."
      puts "Try running with sudo:"
      puts "  sudo #{$0} install"
    end
  end

  private

  def ensure_config_dir
    FileUtils.mkdir_p(CONFIG_DIR) unless Dir.exist?(CONFIG_DIR)
  end

  def load_config
    return {} unless File.exist?(CONFIG_FILE)
    YAML.load_file(CONFIG_FILE) || {}
  end

  def save_config(config)
    File.write(CONFIG_FILE, config.to_yaml)
  end

  def configure_llm
    RubyLLM.configure do |config|
      # --- Provider API Keys ---
      # Only configure providers available in environment
      config.openai_api_key = ENV.fetch('OPENAI_API_KEY', nil)
      config.openai_organization_id = ENV.fetch('OPENAI_ORGANIZATION_ID', nil)
      config.openai_project_id = ENV.fetch('OPENAI_PROJECT_ID', nil)
      config.anthropic_api_key = ENV.fetch('ANTHROPIC_API_KEY', nil)
      config.gemini_api_key = ENV.fetch('GEMINI_API_KEY', nil)
      config.deepseek_api_key = ENV.fetch('DEEPSEEK_API_KEY', nil)
      config.openrouter_api_key = ENV.fetch('OPENROUTER_API_KEY', nil)
      config.perplexity_api_key = ENV.fetch('PERPLEXITY_API_KEY', nil)
      config.mistral_api_key = ENV.fetch('MISTRAL_API_KEY', nil)
      config.ollama_api_base = ENV.fetch('OLLAMA_API_BASE', "http://localhost:11434/v1")
      config.gpustack_api_base = ENV.fetch('GPUSTACK_API_BASE', nil)
      config.gpustack_api_key = ENV.fetch('GPUSTACK_API_KEY', nil)

      # --- AWS Bedrock Credentials ---
      config.bedrock_api_key = ENV.fetch('AWS_ACCESS_KEY_ID', nil)
      config.bedrock_secret_key = ENV.fetch('AWS_SECRET_ACCESS_KEY', nil)
      config.bedrock_region = ENV.fetch('AWS_REGION', nil)
      config.bedrock_session_token = ENV.fetch('AWS_SESSION_TOKEN', nil)

      # --- Custom OpenAI Endpoint ---
      config.openai_api_base = ENV.fetch('OPENAI_API_BASE', nil)

      # --- OpenAI System Role Behavior ---
      # config.openai_use_system_role = false

      # --- Default Models ---
      # Only set if user has specified via environment
      config.default_model = ENV.fetch('DEFAULT_LLM_MODEL', "gemma3")
      config.default_embedding_model = ENV.fetch('DEFAULT_EMBEDDING_MODEL', nil)

      # --- Connection Settings ---
      config.request_timeout = 120
      config.max_retries = 3
      config.retry_interval = 0.1
      config.retry_backoff_factor = 2
      config.retry_interval_randomness = 0.5

      # --- HTTP Proxy Support ---
      config.http_proxy = ENV.fetch('HTTP_PROXY', nil)

      # --- Logging Settings ---
      config.log_level = ENV['DEBUG'] ? :debug : :warn
      config.log_assume_model_exists = true
      # config.log_stream_debug = false
    end
  end

  def check_git_installed
    unless system("git --version > /dev/null 2>&1")
      puts "Git is not installed or not in PATH. Please install git and try again."
      exit 1
    end
    
    unless Dir.exist?(".git")
      puts "Not a git repository. Please run this command in a git repository."
      exit 1
    end
  end

  def check_ollama_connectivity(base_url)
    begin
      uri = URI.parse("#{base_url}/api/tags")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      http.open_timeout = 2
      http.read_timeout = 2
      
      request = Net::HTTP::Get.new(uri.request_uri)
      response = http.request(request)
      
      response.code == "200"
    rescue => e
      false
    end
  end
end

GitCommitCLI.start(ARGV)